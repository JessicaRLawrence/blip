import numpy as np
import matplotlib
#matplotlib.use('Agg')
import matplotlib.pyplot as plt
from chainconsumer import ChainConsumer
import healpy as hp
from healpy import Alm
import pickle, argparse
matplotlib.rcParams.update(matplotlib.rcParamsDefault)


def plotmaker(params, params2, parameters, inj):

    '''
    Make combined posterior plots from two sets of samples generated by tge mcmc/nested sampling algorithm.

    Parameters
    -----------

    params : dictionary
        Dictionary of config params

    parameters: string
        Array or list of strings with names of the parameters

    npar : int
        Dimensionality of the parameter space
    '''

    #post1 = np.loadtxt(params['out_dir'] + "/post_samples.txt")
    #post2 = np.loadtxt(params2['out_dir'] + "/post_samples.txt")

    post1 = np.loadtxt("./2mnths_4/post_samples.txt")
    post2 = np.loadtxt("./12mnths_2/post_samples.txt")



    ## setup the truevals dict
    truevals = []

    if params['modeltype']=='isgwb':

        truevals.append(inj['log_Np'])
        truevals.append( inj['log_Na'])
        truevals.append( inj['alpha'] )
        truevals.append( inj['ln_omega0'] )

    elif params['modeltype']=='noise_only':

        truevals.append(inj['log_Np'])
        truevals.append( inj['log_Na'])

    elif params['modeltype'] =='isgwb_only':

        truevals.append( inj['alpha'] )
        truevals.append( inj['ln_omega0'] )

    elif params['modeltype']=='sph_sgwb':

        truevals.append(inj['log_Np'])
        truevals.append( inj['log_Na'])
        truevals.append( inj['alpha'] )
        truevals.append( inj['ln_omega0'] )

        ## get blms
        for lval in range(1, params['lmax'] + 1):
            for mval in range(lval + 1):

                idx = Alm.getidx(params['lmax'], lval, mval)

                if mval == 0:
                    truevals.append(np.real(inj['blms'][idx]))
                else:
                    #truevals.append(np.abs(inj['blms'][idx]))
                    #truevals.append(np.angle(inj['blms'][idx]))

                    truevals.append(np.abs(inj['blms'][idx]))
                    truevals.append(np.angle(inj['blms'][idx]))

    if params['modeltype']=='dwd_fg':

        truevals.append(inj['log_Np'])
        truevals.append( inj['log_Na'])
        truevals.append( inj['alpha'] )
        truevals.append( inj['ln_omega0'] )

    if len(truevals) > 0:
        knowTrue = 1 ## Bit for whether we know the true vals or not
    else:
        knowTrue = 0

    npar = len(parameters)

    plotrange = [0.999]*npar

    if params['out_dir'][-1] != '/':
        params['out_dir'] = params['out_dir'] + '/'

    ## Make chainconsumer corner plots
    cc = ChainConsumer()
    cc.add_chain(post1, parameters=parameters, name='$2$ months')
    cc.add_chain(post2, parameters=parameters, name='$12$ months')

    cc.configure(smooth=3, kde=False, max_ticks=2, sigmas=np.array([1, 2]), label_font_size=20, tick_font_size=16, \
            summary=False, statistics="max_central", spacing=1, summary_area=0.95, cloud=False, num_cloud=5000, bins=1.2, \
                colors=["#2B72DF", "#B32222"], shade=True, shade_alpha=0.8, bar_shade=True, serif=True)
    cc.configure_truth(color='g', ls='--', alpha=0.7)
    if knowTrue:
        fig = cc.plotter.plot(figsize=(20, 20), truth=truevals)
    else:
        fig = cc.plotter.plot(figsize=(20, 20))

    ## make axis labels to be parameter summaries
    sum_data = cc.analysis.get_summary()
    axes = np.array(fig.axes).reshape((npar, npar))

    '''
    # Adjust axis labels
    for ii in range(npar):
        ax = axes[ii, ii]
        import pdb; pdb.set_trace()

        # get the right summary for the parameter ii
        sum_ax = sum_data[parameters[ii]]
        err =  [sum_ax[2] - sum_ax[1], sum_ax[1]- sum_ax[0]]

        if np.abs(sum_ax[1]) <= 1e-3:
            mean_def = '{0:.3e}'.format(sum_ax[1])
            eidx = mean_def.find('e')
            base = float(mean_def[0:eidx])
            exponent = int(mean_def[eidx+1:])
            mean_form = str(base) + ' \\times ' + '10^{' + str(exponent) + '} '
        else:
            mean_form = '{0:.3f}'.format(sum_ax[1])

        if np.abs(err[0]) <= 1e-2:
            err[0] = '{0:.4f}'.format(err[0])
        else:
            err[0] = '{0:.2f}'.format(err[0])

        if np.abs(err[1]) <= 1e-2:
            err[1] = '{0:.4f}'.format(err[1])
        else:
            err[1] = '{0:.2f}'.format(err[1])

        label =  parameters[ii][:-1] + ' = ' + mean_form + '^{+' + err[0] + '}_{-' + err[1] + '}$'

        ax.set_title(label, {'fontsize':18}, loc='left')
    '''
    ## Save posterior
    # plt.tight_layout()
    plt.savefig('corners.png', dpi=150)
    print("Posteriors plots printed in corners.png")
    plt.close()



if __name__ == '__main__':

    # Create parser
    parser = argparse.ArgumentParser(prog='plotmaker', usage='%(prog)s [options] rundir1 rundir2', description='run plotmaker')

    # Add arguments
    parser.add_argument('rundir1', metavar='rundir1', type=str, help='The path to the run directory')
    parser.add_argument('rundir2', metavar='rundir2', type=str, help='The path to the run directory')

    # execute parser
    args = parser.parse_args()


    paramfile1 = open(args.rundir1 + '/config.pickle', 'rb')

    ## things are loaded from the pickle file in the same order they are put in
    params1 = pickle.load(paramfile1)
    inj1 = pickle.load(paramfile1)
    parameters1 = pickle.load(paramfile1)

    paramfile2 = open(args.rundir2 + '/config.pickle', 'rb')

    ## things are loaded from the pickle file in the same order they are put in
    params2 = pickle.load(paramfile2)
    inj2 = pickle.load(paramfile2)
    parameters2 = pickle.load(paramfile2)


    plotmaker(params1, params2, parameters1, inj1)
